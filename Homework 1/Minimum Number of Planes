#include <stdio.h>
#include "the1.h"

int calculate_planes_helper(int land_length, int land_width, int plane_capacities[], int num_of_planes, int start)
{
    int i; 
    
    if (land_length == 0 || land_width == 0)
    {
        return 0;
    }
    
    for (i = start; i < num_of_planes; i++)
    {
        if (land_length >= plane_capacities[i] && land_width >= plane_capacities[i])
        {
            return 1 + calculate_planes_helper(land_length - plane_capacities[i], plane_capacities[i], plane_capacities, num_of_planes, start) + calculate_planes_helper(land_length, land_width - plane_capacities[i], plane_capacities, num_of_planes, start);
        }
    }
}

int calculate_planes(int land_length, int land_width, int plane_capacities[], int num_of_planes)
{
    /* IMPLEMENT THIS FUNCTION */
    int i, minimum, currentResult;
    
    minimum = calculate_planes_helper(land_length, land_width, plane_capacities, num_of_planes, 0);
    
    for (i = 1; i < num_of_planes; i++)
    {
        currentResult = calculate_planes_helper(land_length, land_width, plane_capacities, num_of_planes, i);
        if (currentResult < minimum)
        {
            minimum = currentResult;
        }
    }
    
    return minimum;
}

void task2_planes(void)
{
    /* IMPLEMENT THIS FUNCTION AND CALL calculate_planes() */
    int land_length, land_width, plane_capacities[5], num_of_planes, i, result;
    scanf("%d %d %d", &land_length, &land_width, &num_of_planes);
    for (i = 0; i < num_of_planes; i++)
    {
        scanf("%d", &plane_capacities[i]);
    }
    
    /* call to the above function */
    result = calculate_planes(land_length, land_width, plane_capacities, num_of_planes);
    printf("%d planes\n", result);
}

int main(void)
{
    /* DO NOT CHANGE main() FUNCTION IMPLEMENTATION */
    int task_id;
    
    scanf("%d", &task_id);
    
    switch(task_id) {
        case 1:
            task1_assembly();
            break;
        case 2:
            task2_planes();
            break;
        default:
            /* no op */
            break;
    }

    return 0;
}

/*

planes are K x K
lands  are M x N
the number of plane types can be changed
unit of land is 10 x 10 for both lands and planes
plane capacities are given in ascending order (might be useful for recursion)

split:     we know the answer for remaining two lands
terminate: when one or both of the land_width and land_length are zero
combine:   use first plane and give it to ASD, consider not using the biggest plane

2
600 900
3
600
300
60

calculate_planes(600, 900, {600, 300, 60}, 3)

note that there are two functions here
there are more than one solutions here and the minimum case might NOT include the plane with maximum capacity
what does it mean "to traverse possible solutions?", I think I did not do this in 111. Maybe I should watch the recursion video on odtuclass
when we use one plane, remaining land is divided into two areas (maybe two recursive calls here)
when we use  K x K plane in an M x N land
    remaining lands are (M-K x K) and (M x N-K)
I expect return value to be a "number"
how to keep the count? => by returning 1 in the terminatiion case
should I also consider eliminating biggest planes one by one? yes, last task is about this
    in this case, there would be cases where there are no solutions
    starting the loop not only from 0 but also from 1, 2, until (num_of_planes - 1) and saving the minimum
    what if this is coded in the recursion?
    there are two possible solutions for me right now
        starting the loop not only from 0 but also from 1, 2, until (num_of_planes - 1)
            how to save the first result to minimum?
        helper function
    
we can find the result with a starting value for the plane array

initializations
    land_length, land_width, plane_capacities[], num_of_planes, i
read inputs (in task2_planes)
    land_length, land_width, plane_capacities[], num_of_planes
call the helper function with start values from 0 to (num_of_planes-1)
    save the minimum (how?)
helper function
    split:     answers for other two lands are known
    terminate: when land_length = 0 or land_width = 0, return 0 because we cannot use a plane for a "nonexisting land"
    combine:   use the appropriate plane from array and give remaining "lands" to ASD
        (for loop) try planes from start to end to find the one which (land_length >= plane) and (land_width >= plane)
            after finding, use that plane
            remaining lands are (M-K x K) and (M x N-K), call the function two times for these lands
        
print the result with a newline

*/
